# 跳表(Skip List)

作为一种`动态数据结构`，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代`红黑树`。

Redis 中的有序集合`Sorted Set`的就是用跳表来实现的（还由双hash mao构成的字典共同实现）。

跳表示意图：
![跳表示意图](./imgs/skip_list.jpg)

总结一下：**这种链表加多级索引的结构，就是跳表**。

图示：若总数为`n`，第`k`级索引的结点个数是第`k-1`级索引的结点个数的`1/m`，则第`k`级索引结点的个数就是 n/m<sup>k</sup>。

***时间复杂度***：

- 假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，可以得到 n/(2<sup>h</sup>)=2；移项可得 h=log<sub>2</sub>n-1，加上原始链表，那么整个跳表高度为log<sub>2</sub>n；
- 如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。
- 这里 m 的具体值，如以 2 分结点，当 k 级索引到结点x,y时满足，在down指针下降到索引级 k-1 时，是需要遍历3个的（包括x,y）。那么时间复杂度即`O(logn)`。

***空间复杂度***：

`n/2 + n/4 + n/8 + ... + 8 + 4 + 2 = n - 2` 即空间复杂度为 o(n)。

***高效的动态插入和删除***

跳表不仅支持查找操作，还支持动态的插入、删除操作，且时间复杂度也是 O(logn)。

跳表本质上就是链表，所以仅插作，插入和删除操时间复杂度就为O(1)，但在实际情况中，要插入或删除某个节点，需要先查找到指定位置，而这个查找操作比较费时。

插入操作：查找操作O(logn) * 插入操作O(1)。

删除操作：如果这个结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。在查找要删除的结点的时候，还需要获取前驱结点，然后通过指针操作完成删除。

***跳表索引动态更新***

**出发点**：如果不停的往跳表中插入数据，也不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。

**平衡性**：如同红黑树、AVL 树这样平衡二叉树，它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过`随机函数`来维护“平衡性”。

往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。

**How？** 通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，就将这个结点添加到第1级到第 K 级索引中。
