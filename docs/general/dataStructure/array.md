# 数组(Array)

数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
这也是数组最大特点：**支持随机访问**的原因。

一维数组寻址：`a[i]_address = base_address + i * data_type_size`。

二维数组寻址：对于 m * n 的数组，a [ i ][ j ] (i < m, j < n)的地址
`address = base_address + ( i * n + j) * data_type_size`。

- `访问`操作
  用下标随机访问，时间复杂度为 ***O(1)*** ；若使用二分查找，时间复杂度为 ***O(logn)*** ；

- `插入、删除`操作，时间复杂度为 ***O(n)***
  `最好时间复杂度`为 ***O(1)*** ，`最坏时间复杂度`为 ***O(n)*** ，`平均时间复杂度`为 ***(1+2+...+n)/n = O(n)*** （加权平均）。
  
在Python中，数组支持负数下标。

## 访问越界问题

根据数组寻址公式，且访问数组的本质就是访问一段连续内存，
只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。反之会报错，

``` py
a = [1, 2]
a[2] = 4

发生异常: IndexError
list assignment index out of range
```

从数组存储的内存模型上来看，数组“下标”最确切的定义应该是“偏移（offset）”。

## JVM（Java虚拟机）应用

- 出发点：
  如果每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。
- JVM标记清除算法：
  大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。

  不足：
    1. 效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。
    2. 空间问题。会产生不连续的内存空间碎片。